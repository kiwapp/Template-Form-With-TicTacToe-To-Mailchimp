(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function(){
    "use strict";
    function EventEmitter(){
        this.events = {};
    }

    EventEmitter.prototype.on = function(eventName, callback, instance) {

        if(!this.events[eventName]) {
            this.events[eventName] = [];
        }

        this.events[eventName].push({callback : callback, instance : instance});
    };

    EventEmitter.prototype.trigger = function(events) {

        var args = Array.prototype.slice.call(arguments);
        args.shift();

        if(!Array.isArray(events)) {
            events = [events];
        }

        for(var i = 0; i < events.length; i++) {

            var eventName = events[i],
                splitName = eventName.split("*");

            if(splitName.length <= 1){
                if(!this.events[eventName]) {
                    continue;
                }

                for(var o = 0; o < this.events[eventName].length; o++) {
                    this.events[eventName][o].callback.apply(this.events[eventName][o].instance , args);
                }

            } else{
                for(var x in this.events) {

                    if(x.indexOf(splitName[1]) > -1) {
                        eventName = x;

                        for(var o = 0; o < this.events[eventName].length; o++) {
                            this.events[eventName][o].callback.apply(this.events[eventName][o].instance, args);
                        }
                    }
                }
            }
        }
    };

    module.exports = EventEmitter;
})();
},{}],2:[function(require,module,exports){
(function() {
    "use strict";
    var EventEmitter = require("./events");

    // Detect if we have a touch event
    var isTouch = !!('ontouchstart' in window);
    var eventName = (isTouch) ? 'touchmove' : 'mousemove';
    //request anim frame, allow fluid gameLoop to draw canvases
    var requestAnimFrame = (function(){
        return  window.requestAnimationFrame       ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame    ||
                function( callback ){
                    window.setTimeout(callback, 1000 / 60);
          };
    })();


 /**
     * ScratchCard component
     * Ex configuration
     *     {
     *          "picture" : [{ // Different conditions
     *                  "path" : "images",
     *                  "file": "step2.jpg",
     *                  "luck" : 60 // luck percentage for this step,
     *                  "event" : "fail", // name of the event to trigger
     *              },{
     *                  "path" : "images",
     *                  "file": "step3.jpg",
     *                  "luck" : 40,
     *                  "event" : "success",
     *              }],
     *          "foreground" : {
     *              "path" : "images",
     *              "file" : "step1.jpg"
     *          },
     *          "brushRadius" : 40, // Width of the scracth touch
     *          "minCompletion" : 40 // Percentage to trigger the event,
     *          "width" : 500, // Width of the canvas
     *          "height" : 500 // Height of the canvas
     *  }
     * @param {DOMElement} element
     * @param {Object} params
     */
    function ScratchCard(element,params) {
        EventEmitter.call(this);
        this.$el       = element;
        this.params    = params;
        this.canvas    = {};
        this.complete  = false;
        this.eventName = 'error';
        this.requestId = 'error';

        var init = function init(self) {

            Kiwapp.log('[ScratchCard@init] Create a new instance of the game');
            Kiwapp.log('[ScratchCard@init] configuration : ' + JSON.stringify(params));
            self.$el.innerHTML = '';
            self.params.brushRadius   = self.params.brushRadius || 40;
            self.params.minCompletion = self.params.minCompletion || 50;
            self.setSize();
            self.make();
            self.loop();

            return self.canvas;
        }(this);
    }

    ScratchCard.prototype = Object.create(EventEmitter.prototype);

    /**
     * Draw the canvas and the buffer
     */
    ScratchCard.prototype.draw = function() {

        var render = this.canvas,
            height = this.params.height,
            width  = this.params.width;

        // Clean the canvas
        render.ctx.clearRect(0,0,width,height);

        //draw foreground
        if (render.foreground !== null) {
            render.ctx.drawImage(render.foreground,0,0,width,height);
        }
        // debugger;
        //draw the already scrached surface on it
        render.ctx.drawImage(render.buffer,0,0,width,height);
    };

    /**
     * RequestAnimation frame loop to draw the game
     */
    ScratchCard.prototype.loop = function() {

        var that = this;
        that.draw();

        if(!this.complete) {
            this.requestId = requestAnimFrame(function(){
                that.loop();
            });
        }
    };

    /**
     * Find teh condition for the current game based on your luck percentage's
     */
    ScratchCard.prototype.chooseSituations = function() {

        var leftChances = 100,
            diceRoll    = Math.random() * leftChances,
            pictures    = this.params.picture;

        for (var i in pictures) {
            if (diceRoll <= pictures[i].luck) {
                return pictures[i];
            }else {
                leftChances -=  pictures[i].luck;
                diceRoll     = Math.random() * leftChances;
            }
        }
    };

    /**
     * Set size for the canvas based of the container if you do not set
     * width and height in the params
     */
    ScratchCard.prototype.setSize = function() {

        var size = this.$el.getBoundingClientRect(),
            that = this;

        that.params.width    = that.params.width || Math.round(size.width);
        that.params.height   = that.params.height || Math.round(size.height);

        Kiwapp.log('[ScratchCard@setSize] Display the scracthcard for ' + that.params.width + 'x' + that.params.height);
    };

    /**
     * Build the canvas and the buffer.
     * @return {[type]} [description]
     */
    ScratchCard.prototype.make = function() {

        var canvas     = document.createElement("canvas"),
            buffer     = document.createElement("canvas"),
            img        = new Image(),
            foreground = new Image(),
            params     = this.params,
            picture    = this.chooseSituations();

        canvas.id = 'canvas-' + Math.round(Math.random()*100);
        buffer.id = 'canvas-' + Math.round(Math.random()*1001);
        params.details = picture.details;
        this.eventName = picture.event;
        // Event listener to detect the scracth and if we have won
        this.listener(canvas);
        img.src = picture.path + '/' + picture.file;

        img.width = canvas.width  = buffer.width  = params.width;
        img.height = canvas.height = buffer.height = params.height;

        var resizeBuffer = document.createElement("canvas");
        var resizeBufferCtx = resizeBuffer.getContext("2d");
        // peut etre virer canvas brush pas necessaire maybe
        resizeBuffer.width = canvas.width;
        resizeBuffer.height = canvas.height;

            // Append the canvas into the dom
        this.$el.appendChild(canvas);
        if("foreground" in params) {
            foreground.src = params.foreground.path + '/' + params.foreground.file;
            foreground.width = params.width;
            foreground.height = params.height;
        }

        // My little config
        this.canvas = {
            "canvas"     : canvas,
            "ctx"        : canvas.getContext("2d"),
            "buffer"     : buffer,
            "bufferCtx"  : buffer.getContext("2d"),
            "img"        : img,
            "foreground" : foreground || null,
            "grid"       : this.generateGrid(canvas),
            "fillCount"  : 0,
            "bufferSizer": resizeBuffer,
            "resizeBufferCtx"  : resizeBufferCtx,
            "count"  : 0
        };

        if("foreground" in params) {
            foreground.src = params.foreground.path + '/' + params.foreground.file;
            foreground.width = params.width;
            foreground.height = params.height;
        }

        Kiwapp.log('[ScratchCard@make] The canvas is ready');
    };

    /**
     * Set an invisible grid to allow completion tracking
     * @param  {DOMElement} canvas
     * @return {Array}        the grid
     */
    ScratchCard.prototype.generateGrid = function(canvas) {

        var grid = [];
        for (var i = 0; i < 10; i++) {

            for (var j = 0; j < 10; j++) {
                grid.push({
                    "width"  : canvas.width/10,
                    "height" : canvas.width/10,
                    "x"      : i*(canvas.width/10),
                    "y"      : j*(canvas.height/10),
                    "active" : true
                });
            }
        }
        return grid;
    };

    /**
     * Event listener
     *     -Detect the scracth completion
     *     -Detect if we have won based on this.minCompletion
     * @param  {DOMElement} element the canvas
     */
    ScratchCard.prototype.listener = function(element) {
        var that = this;

        // Canvas listener
        var listenerCanvas = function(e){

            if(!that.complete) {

                if( navigator.userAgent.match(/Android/i) ) {
                    e.preventDefault();
                }
                // Actions on the canvas
                that.actions(e);
                that.isComplete(element, listenerCanvas);
                return;
            }
        };

        element.addEventListener(eventName, listenerCanvas,false);
    };

    /**
     * Some tasks to run when the user scracth
     * @param  {Event} evt
     */
    ScratchCard.prototype.actions = function(evt) {

        var mouseX     = 0,
            mouseY     = 0,
            config     = this.canvas,
            params     = this.params,
            gridLength = config.grid.length;

        // Draw of the img into the canvas used for resize the img
       if (this.canvas.count%30===0)
       {
        config.resizeBufferCtx.drawImage(config.img,0,0,config.canvas.width,config.canvas.height);
       }
        this.canvas.count++;

        if(isTouch) {
            mouseX = evt.targetTouches[0].pageX - (config.canvas.offsetLeft);
            mouseY = evt.targetTouches[0].pageY - (config.canvas.offsetTop);
        }else {
            mouseX = evt.pageX;
            mouseY = evt.pageY;
        }

        config.img.width = params.width;
        config.img.height = params.height;

        //we draw on the buffer the surface scratched by the mouse  and the img use is from bufferSizer who containe one canvas use for resize img with canvas size.

        config.bufferCtx.beginPath();
        config.bufferCtx.fillStyle = config.bufferCtx.createPattern(config.bufferSizer, "no-repeat");
        config.bufferCtx.arc(mouseX, mouseY, params.brushRadius, 0, 2*Math.PI, false);
        config.bufferCtx.fill();

        //we check if we have draw into a cell
        for (var cellNum in config.grid) {

            //if yes, we put the cell to an inactive state
            if (!config.grid[cellNum].active){
                continue;
            }else if (
                mouseX + params.brushRadius >= config.grid[cellNum].x &&
                mouseX - params.brushRadius < config.grid[cellNum].x + config.grid[cellNum].width &&
                mouseY + params.brushRadius >= config.grid[cellNum].y &&
                mouseY - params.brushRadius < config.grid[cellNum].y + config.grid[cellNum].height) {
                config.grid[cellNum].active = false;
            }
        }

        //we refresh the fill percentage of the grid of the selected canvas
        config.fillCount = 0;
        for (var i = 0 ; i < gridLength ; i ++) {
            if (!config.grid[i].active){
                config.fillCount++;
            }
        }
    };

    /**
     * Is it done ?
     */
    ScratchCard.prototype.isComplete = function(element, callback) {

        var that = this;

        if(that.canvas.fillCount >= that.params.minCompletion) {
            element.removeEventListener(eventName,callback);
            that.complete = true;
            that.trigger(that.eventName,that.params.details);
            Kiwapp.log('[ScratchCard@isComplete] Trigger an event : ' + that.eventName);
        }

        return that.canvas.fillCount >= that.params.minCompletion;
    };

    window.ScratchCard = ScratchCard;
    module.exports = ScratchCard;
})();
},{"./events":1}]},{},[2])